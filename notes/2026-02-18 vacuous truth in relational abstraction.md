## Current status

I'm working on implementing a feature that checks vacuous truth of relational abstraction. For example, let's say we want to commutative property of addition, add(a,b) == add(b,a). If we write this property with functions, we can write this as $\forall a,b \  add(a,b) == add(b,a)$. With relatioanl abstraction, this property will be described as $\forall a,b,c,d  \ Rel_{add}(a,b,c) \wedge Rel_{add}(b,a,d) \implies c == d$. The formula can be true if every term $Rel_{add}(a,b,c), Rel_{add}(b,a,d), c == d$ is true, and can be vacuously true(i.e. $Rel_{add}(a,b,c)$ is false, $Rel_{add}(b,a,d)$ is false, or both of them are false). In this case, c == d does not need to be true, thus it makes verification failure. If Ravencheck can report, for example, $Rel_{add}(a,b,c)$ is false, then user can know that add(a,b) is not instantiated, thus we need to add `let _ = add(a,b);`.


I'm currently dealing with the code below. It fails on the last subcase.

```
#[ravencheck::check_module]
//#[crate::check_module(crate)]
#[allow(dead_code)]
mod rvn {
    #[define]
    #[derive(Clone, Debug, PartialEq, Eq)]
    enum Nat {
        // The zero variant
        Z,
        // The successor variant. The sub-value needs to go inside a
        // Box (i.e. needs to get heap-allocated) so that Nat has a
        // fixed byte-size, which is a requirement for all types in
        // Rust.
        //
        // You unbox a value `n: Box<Nat>` using `*n`.
        //
        // You re-box a value `n: Nat` using `Box::new(n)`.
        S(Box<Nat>)
    }

    #[define]
    #[recursive]
    fn add(a: Nat, b: Nat) -> Nat {
        match a {
            Nat::Z => b,
            Nat::S(a_minus) =>
                // We unbox `a_minus` before calling `add`, and then
                // re-box the output of `add` so that we can wrap it
                // in Nat::S.
                Nat::S(Box::new(add(*a_minus,b))),
        }
    }
    
    #[define]
    #[recursive]
    fn sub(a: Nat, b: Nat) -> Nat {
        match a.clone() {
            Nat::Z => Nat::Z, // 0 - b = 0
            Nat::S(a_minus) => match b {
                Nat::Z => a, // a - 0 = a
                // else, sub(dec(a), dec(b))
                Nat::S(b_minus) => sub(*a_minus, *b_minus)
            }
        }
    }

    #[annotate]
    #[inductive(a: Nat)]
    fn add_z_left() -> bool {
        add(Nat::Z, a) == a
    }

    #[annotate]
    #[inductive(a: Nat)]
    fn add_z_right() -> bool {
        add(a, Nat::Z) == a
    }

    #[annotate]
    #[inductive(a: Nat, b: Nat)]
    fn add_move_s() -> bool {
        add(Nat::S(a), b) == add(a, Nat::S(b))
    }

    #[annotate]
    #[inductive(a: Nat, b: Nat)]
    fn add_commutative() -> bool {
        add(a,b) == add(b,a)
    }
}
```

In SMT level, Ravencheck asks to CVC5 like below
```
;; Auto-generated by Ravencheck
(set-logic ALL)
(set-option :produce-models true)
(set-option :finite-model-find true)
(set-option :produce-unsat-cores true)
(declare-fun F_special_recursive____ () Bool)
(declare-sort UI_Nat 0)
(declare-fun F_Nat__S____ (UI_Nat UI_Nat) Bool)
;; Rel-Fun for Nat::S
(assert (forall ((xn_0 UI_Nat)) (forall ((xn_2 UI_Nat)) (forall ((xn_4 UI_Nat)) (or (= xn_2 xn_4) (or (not (F_Nat__S____ xn_0 xn_4)) (not (F_Nat__S____ xn_0 xn_2))))))))
(declare-fun F_Nat__Z____ () UI_Nat)
;; Rel-Con-Same for Nat::S
(assert (forall ((xn_0 UI_Nat)) (forall ((xn_2 UI_Nat)) (forall ((xn_4 UI_Nat)) (or (= xn_0 xn_2) (or (not (F_Nat__S____ xn_2 xn_4)) (not (F_Nat__S____ xn_0 xn_4))))))))
;; Rel-Con-Same for Nat::Z
(assert (forall ((xn_2 UI_Nat)) (or true (or (distinct F_Nat__Z____ xn_2) (distinct F_Nat__Z____ xn_2)))))
;; Rel-Con-Diff for Nat::Z vs Nat::S
(assert (forall ((xn_1 UI_Nat)) (forall ((xn_3 UI_Nat)) (or (not (F_Nat__S____ xn_1 xn_3)) (distinct F_Nat__Z____ xn_3)))))
(declare-fun F_substruct__UI_Nat__ (UI_Nat UI_Nat) Bool)
(declare-fun F_add____ (UI_Nat UI_Nat UI_Nat) Bool)
;; Rel-Fun for add
(assert (forall ((xn_0 UI_Nat) (xn_1 UI_Nat)) (forall ((xn_3 UI_Nat)) (forall ((xn_5 UI_Nat)) (or (= xn_3 xn_5) (or (not (F_add____ xn_0 xn_1 xn_5)) (not (F_add____ xn_0 xn_1 xn_3))))))))
;; Axiom: add_z_left
(assert (forall ((x_a UI_Nat)) (forall ((xn_7 UI_Nat)) (or (= xn_7 x_a) (not (F_add____ F_Nat__Z____ x_a xn_7))))))
;; Axiom: add_z_right
(assert (forall ((x_a UI_Nat)) (forall ((xn_7 UI_Nat)) (or (= xn_7 x_a) (not (F_add____ x_a F_Nat__Z____ xn_7))))))
;; Axiom: add_move_s
(assert (forall ((x_a UI_Nat) (x_b UI_Nat)) (forall ((xn_14 UI_Nat)) (forall ((xn_15 UI_Nat)) (forall ((xn_16 UI_Nat)) (forall ((xn_17 UI_Nat)) (or (or (or (or (= xn_15 xn_17) (not (F_Nat__S____ x_a xn_14))) (not (F_add____ xn_14 x_b xn_15))) (not (F_Nat__S____ x_b xn_16))) (not (F_add____ x_a xn_16 xn_17)))))))))
;; Axiom: Substruct_Nat_0
(assert (forall ((xn_0 UI_Nat)) (F_substruct__UI_Nat__ xn_0 xn_0)))
;; Axiom: Substruct_Nat_1
(assert (forall ((xn_0 UI_Nat) (xn_1 UI_Nat) (xn_2 UI_Nat)) (or (F_substruct__UI_Nat__ xn_0 xn_2) (or (not (F_substruct__UI_Nat__ xn_1 xn_2)) (not (F_substruct__UI_Nat__ xn_0 xn_1))))))
;; Axiom: Substruct_Nat_2
(assert (forall ((xn_0 UI_Nat) (xn_1 UI_Nat)) (or (= xn_0 xn_1) (or (not (F_substruct__UI_Nat__ xn_1 xn_0)) (not (F_substruct__UI_Nat__ xn_0 xn_1))))))
;; Axiom: Substruct_Nat_3
(assert (forall ((xn_0 UI_Nat)) (forall ((xn_2 UI_Nat)) (or (and (distinct xn_0 xn_2) (F_substruct__UI_Nat__ xn_0 xn_2)) (not (F_Nat__S____ xn_0 xn_2))))))
;; Axiom: Substruct_Nat_4
(assert (forall ((xn_1 UI_Nat)) (or (forall ((xn_3 UI_Nat)) (= (F_substruct__UI_Nat__ xn_3 xn_1) (= xn_3 xn_1))) (distinct F_Nat__Z____ xn_1))))
;; --- Verification Condition ---
(assert 
  (exists ((x_a UI_Nat) (x_b UI_Nat)) (exists ((xn_11 UI_Nat)) (exists ((xn_94 UI_Nat)) (exists ((xn_95 UI_Nat)) (and (and (and (exists ((xn_20 UI_Nat)) (exists ((xn_105 UI_Nat)) (exists ((xn_106 UI_Nat)) (and (and (and (and (distinct xn_95 xn_106) (forall ((xn_29 UI_Nat) (xn_30 UI_Nat)) (or (forall ((xn_56 UI_Nat)) (forall ((xn_57 UI_Nat)) (or (or (= xn_56 xn_57) (not (F_add____ xn_29 xn_30 xn_56))) (not (F_add____ xn_30 xn_29 xn_57))))) (or (and (= xn_30 x_b) (= xn_29 x_a)) (or (not (F_substruct__UI_Nat__ xn_30 x_b)) (not (F_substruct__UI_Nat__ xn_29 x_a))))))) (F_Nat__S____ xn_20 x_b)) (F_add____ xn_20 x_a xn_105)) (F_Nat__S____ xn_105 xn_106))))) (F_Nat__S____ xn_11 x_a)) (F_add____ xn_11 x_b xn_94)) (F_Nat__S____ xn_94 xn_95))))))
)
(check-sat)
```
